-- ===============================
-- ROBLOX BRAINROT SCANNER V8.1 FIXED
-- ‚úÖ FIXED: Brainrot Scanner funktioniert jetzt!
-- ‚úÖ Using V5.0 scanning method (GetDescendants)
-- ===============================

if not game:IsLoaded() then game.Loaded:Wait() end
repeat task.wait() until game:GetService("Players").LocalPlayer

local workspace = game:GetService('Workspace')
local Players = game:GetService('Players')
local TeleportService = game:GetService('TeleportService')
local HttpService = game:GetService('HttpService')
local CoreGui = game:GetService('CoreGui')
local Lighting = game:GetService('Lighting')
local RunService = game:GetService('RunService')

repeat wait(0.1) until Players.LocalPlayer

-- ===============================
-- KONFIGURATION
-- ===============================
local VPS_URL = "https://roblox-brainrot-scanner.therixyt4.workers.dev/api"
local API_SECRET = "123"
local VPS_PLACE_ID = 109983668079237
local MIN_GENERATION = 10
local USERNAME = Players.LocalPlayer.Name

-- HOPPING SETTINGS
local WAIT_FOR_LOAD = 5       -- Wie lange auf Game Load warten
local SCAN_TIME = 4           -- Wie lange scannen
local HOP_DELAY = 9           -- Total Zeit pro Server (Load + Scan)

local SPECIAL_WEBHOOK = "https://ptb.discord.com/api/webhooks/1466088189260468458/Vi19cPhLJXGckt_0IDjRa6MkGixFznByJ_0BlNmKx0h84VlBgJtrPmtHWmbDHiW3eOPe"
local SPECIAL_MIN_GEN = 200
local SPECIAL_BRAINROTS = {
    ["garama and madundung"] = true, ["la casa boo"] = true, ["festive 67"] = true,
    ["la ginger sekolah"] = true, ["ketchuru and musturu"] = true, ["la taco combinasion"] = true,
    ["spaghetti aualetti"] = true, ["tang tang keletang"] = true, ["la secret combinasion"] = true,
    ["chillin chili"] = true, ["lavadorito spinito"] = true, ["celularcini viciosini"] = true,
    ["tralaledon"] = true, ["ketupat kepat"] = true, ["tictac sahur"] = true,
    ["fragrama and chocrama"] = true
}

local http_request = (syn and syn.request) or (http and http.request) or http_request or (fluxus and fluxus.request) or request
if not http_request then
    error("‚ùå ERROR: Your executor doesn't support HTTP requests!")
end

-- ===============================
-- WHITE SCREEN UI
-- ===============================
local function createWhiteScreen()
    local whiteScreen = Instance.new("ScreenGui")
    whiteScreen.Name = "LuxarToolsScreen"
    whiteScreen.IgnoreGuiInset = true
    whiteScreen.DisplayOrder = 999999999
    whiteScreen.ResetOnSpawn = false
    whiteScreen.Enabled = true
    whiteScreen.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    
    local success = pcall(function() 
        whiteScreen.Parent = CoreGui
    end)
    if not success or not whiteScreen.Parent then
        local playerGui = Players.LocalPlayer:WaitForChild("PlayerGui", 5)
        if playerGui then
            whiteScreen.Parent = playerGui
        end
    end
    
    local bg = Instance.new("Frame")
    bg.Size = UDim2.new(1, 0, 1, 0)
    bg.Position = UDim2.new(0, 0, 0, 0)
    bg.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
    bg.BorderSizePixel = 0
    bg.ZIndex = 999999999
    bg.Parent = whiteScreen
    
    local title = Instance.new("TextLabel")
    title.Size = UDim2.new(1, 0, 0, 100)
    title.Position = UDim2.new(0, 0, 0.5, -50)
    title.BackgroundTransparency = 1
    title.Text = "LUXAR TOOLS V8.1 FIXED"
    title.TextColor3 = Color3.fromRGB(40, 40, 40)
    title.TextSize = 72
    title.Font = Enum.Font.GothamBold
    title.TextXAlignment = Enum.TextXAlignment.Center
    title.ZIndex = 1000000000
    title.Parent = bg
    
    local status = Instance.new("TextLabel")
    status.Size = UDim2.new(1, 0, 0, 30)
    status.Position = UDim2.new(0, 0, 0.5, 60)
    status.BackgroundTransparency = 1
    status.Text = "Initializing..."
    status.TextColor3 = Color3.fromRGB(100, 100, 100)
    status.TextSize = 18
    status.Font = Enum.Font.Gotham
    status.TextXAlignment = Enum.TextXAlignment.Center
    status.ZIndex = 1000000000
    status.Parent = bg
    
    local timer = Instance.new("TextLabel")
    timer.Size = UDim2.new(1, 0, 0, 25)
    timer.Position = UDim2.new(0, 0, 0.5, 90)
    timer.BackgroundTransparency = 1
    timer.Text = ""
    timer.TextColor3 = Color3.fromRGB(150, 150, 150)
    timer.TextSize = 16
    timer.Font = Enum.Font.Gotham
    timer.TextXAlignment = Enum.TextXAlignment.Center
    timer.ZIndex = 1000000000
    timer.Parent = bg
    
    return whiteScreen, status, timer
end

local whiteScreenGui, statusLabel, timerLabel = createWhiteScreen()
local function updateStatus(text)
    if statusLabel then statusLabel.Text = text end
    print("üìä " .. text)
end
local function updateTimer(text)
    if timerLabel then timerLabel.Text = text end
end

-- ===============================
-- PERFORMANCE OPTIMIZATIONS
-- ===============================
if setfpscap then setfpscap(20) end

task.spawn(function()
    pcall(function()
        Lighting.GlobalShadows = false
        Lighting.Brightness = 0
        Lighting.FogEnd = 1
        task.wait(0.1)
        for _, effect in ipairs(Lighting:GetChildren()) do
            if effect:IsA("PostEffect") or effect:IsA("Atmosphere") or effect:IsA("Sky") then
                pcall(function() effect:Destroy() end)
            end
        end
    end)
    task.wait(0.1)
    pcall(function()
        local terrain = workspace.Terrain
        terrain.WaterWaveSize = 0
        terrain.WaterWaveSpeed = 0
        terrain.WaterTransparency = 1
        terrain.Decoration = false
    end)
    task.wait(0.1)
    pcall(function()
        RunService:Set3dRenderingEnabled(false)
    end)
end)

-- ===============================
-- HELPER FUNCTIONS
-- ===============================
local function parseMoneyPerSec(text)
    if not text or not text:find("/s") then return 0 end
    text = text:gsub("%$",""):gsub("/s",""):gsub("%s+","")
    local multiplier = text:find("[Bb]") and 1e9 or text:find("[Mm]") and 1e6 or text:find("[Kk]") and 1e3 or text:find("[Tt]") and 1e12 or 1
    text = text:gsub("[KkMmBbTt]","")
    return tonumber(text) and tonumber(text) * multiplier or 0
end

local function getUsernameFromDisplayName(displayName)
    for _, player in pairs(Players:GetPlayers()) do
        if player.DisplayName == displayName or player.Name == displayName then 
            return player.Name 
        end
    end
    return nil
end

local function getUsernameFromPlot(plot)
    local success, result = pcall(function()
        if plot:FindFirstChild('Owner') then
            local owner = plot.Owner
            if owner:IsA('StringValue') then return owner.Value end
            if owner:IsA('ObjectValue') and owner.Value then return owner.Value.Name end
        end
        return plot:GetAttribute('Owner') or plot:GetAttribute('OwnerName') or 
               (plot:FindFirstChild('OwnerName') and plot.OwnerName:IsA('StringValue') and plot.OwnerName.Value) or nil
    end)
    return success and result or nil
end

local function getPlotOwnerInfo(plotId)
    local success, result = pcall(function()
        local plot = workspace.Plots:FindFirstChild(plotId)
        if not plot then return nil end
        
        local plotSign = plot:FindFirstChild("PlotSign")
        if plotSign then
            local surfaceGui = plotSign:FindFirstChild("SurfaceGui")
            if surfaceGui then
                local frame = surfaceGui:FindFirstChild("Frame")
                if frame then
                    local textLabel = frame:FindFirstChild("TextLabel")
                    if textLabel and textLabel.Text ~= "" then
                        local displayName = textLabel.Text:gsub("'s [Bb]ase", ""):gsub("'s [Pp]lot", ""):match("^%s*(.-)%s*$")
                        if displayName ~= "" then
                            return getUsernameFromDisplayName(displayName) or getUsernameFromPlot(plot) or displayName
                        end
                    end
                end
            end
        end
        return getUsernameFromPlot(plot)
    end)
    return success and result or nil
end

local function findOwnerForBrainrot(brainrotObj)
    local current = brainrotObj.Parent
    while current and current ~= workspace do
        if current.Parent and current.Parent.Name == "Plots" then
            return getPlotOwnerInfo(current.Name) or "Unknown"
        end
        current = current.Parent
    end
    return "Unknown"
end

-- ===============================
-- ‚úÖ FIXED BRAINROT SCANNER (from V5.0)
-- Uses GetDescendants() on entire workspace!
-- ===============================
local function scanAllBrainrots()
    local detections = {}
    local descendants = workspace:GetDescendants()
    local batchSize = 50
    
    print("üîç Starting brainrot scan... (Total objects: " .. #descendants .. ")")
    
    for i = 1, #descendants, batchSize do
        local batchEnd = math.min(i + batchSize - 1, #descendants)
        for j = i, batchEnd do
            local obj = descendants[j]
            -- Looking for TextLabel named "Generation"
            if obj:IsA("TextLabel") and obj.Name == "Generation" then
                local moneyValue = parseMoneyPerSec(obj.Text)
                local moneyM = moneyValue / 1e6
                
                if moneyM >= MIN_GENERATION then
                    local parent = obj.Parent
                    local name = (parent and parent:FindFirstChild("DisplayName") and parent.DisplayName.Text) or "Unknown"
                    local rarity = (parent and parent:FindFirstChild("Rarity") and parent.Rarity.Text) or "Unknown"
                    local mutation = (parent and parent:FindFirstChild("Mutation") and parent.Mutation.Visible and parent.Mutation.Text) or "None"
                    
                    local owner = findOwnerForBrainrot(obj)
                    
                    print("üß† Found brainrot: " .. name .. " - " .. obj.Text .. " - Owner: " .. owner)
                    
                    table.insert(detections, {
                        name = name,
                        generation = obj.Text,
                        rarity = rarity,
                        mutation = mutation,
                        owner = owner,
                        count = 1,
                        genNum = moneyM
                    })
                end
            end
        end
        -- Small delay to prevent lag
        if i % (batchSize * 2) == 0 then
            task.wait(0.01)
        end
    end
    
    -- Sort by generation value
    table.sort(detections, function(a, b) return a.genNum > b.genNum end)
    
    print("üìä Scan complete! Found " .. #detections .. " brainrots")
    return detections
end

-- ===============================
-- HIGHLIGHT SCANNER
-- ===============================
local function scanAllHighlights()
    local highlights = {}
    
    pcall(function()
        local plotsFolder = workspace:FindFirstChild("Plots")
        if not plotsFolder then return end
        
        for _, plot in ipairs(plotsFolder:GetChildren()) do
            if plot.Name:match("^Plot%d+$") then
                local highlight = plot:FindFirstChild("Highlight", true)
                if highlight and highlight:IsA("Highlight") then
                    local owner = getPlotOwnerInfo(plot.Name) or "Unknown"
                    
                    print("‚ú® Found HIGHLIGHT - Plot: " .. plot.Name .. " - Owner: " .. owner)
                    table.insert(highlights, {
                        owner = owner,
                        plotId = plot.Name
                    })
                end
            end
        end
        
        print("üìä Found " .. #highlights .. " highlights")
    end)
    
    return highlights
end

-- ===============================
-- API - OHNE NAMEN!
-- ===============================
local function sendToAPI(brainrots, highlights, serverId)
    if #brainrots == 0 and #highlights == 0 then return end
    
    task.spawn(function()
        local success = pcall(function()
            local filteredBrainrots = {}
            
            for _, br in ipairs(brainrots) do
                local genNum = br.genNum or (parseMoneyPerSec(br.generation) / 1e6)
                if genNum >= MIN_GENERATION then
                    table.insert(filteredBrainrots, {
                        -- ‚ùå NAME ENTFERNT!
                        generation = br.generation,
                        owner = br.owner,
                        plotId = "Unknown"
                    })
                end
            end
            
            if #filteredBrainrots == 0 and #highlights == 0 then 
                print("‚ÑπÔ∏è No brainrots/highlights met threshold")
                return 
            end
            
            local payload = {
                serverId = serverId,
                playerCount = #Players:GetPlayers(),
                maxPlayers = Players.MaxPlayers,
                worker = USERNAME,
                brainrots = filteredBrainrots,
                highlights = highlights
            }
            
            print("üì§ Sending " .. #filteredBrainrots .. " brainrots + " .. #highlights .. " highlights to API...")
            
            local response = http_request({
                Url = VPS_URL .. "/submit",
                Method = "POST",
                Headers = {
                    ["Content-Type"] = "application/json",
                    ["X-API-Secret"] = API_SECRET
                },
                Body = HttpService:JSONEncode(payload)
            })
            
            if response and response.StatusCode == 200 then
                print("‚úÖ Successfully sent to API!")
            else
                print("‚ö†Ô∏è API failed (Status: " .. tostring(response and response.StatusCode or "nil") .. ")")
            end
        end)
        
        if not success then
            print("‚ùå Error sending to API")
        end
    end)
end

local function sendToSpecialWebhook(eligibleBrainrots, serverId)
    if #eligibleBrainrots == 0 or SPECIAL_WEBHOOK == "" then return end
    task.spawn(function()
        pcall(function()
            local titleParts = {}
            for _, br in ipairs(eligibleBrainrots) do
                table.insert(titleParts, br.name .. " " .. br.generation)
            end
            http_request({
                Url = SPECIAL_WEBHOOK,
                Method = "POST",
                Headers = {["Content-Type"] = "application/json"},
                Body = HttpService:JSONEncode({embeds = {{
                    title = table.concat(titleParts, " | "),
                    description = "**Server ID (Real)**\n```" .. serverId .. "```",
                    color = 16776960,
                    footer = { text = "Worker: " .. USERNAME },
                    timestamp = os.date("!%Y-%m-%dT%H:%M:%SZ")
                }}})
            })
        end)
    end)
end

-- ===============================
-- SERVER HOP FUNCTION
-- ===============================
local serverQueue = {}
local lastAPICall = 0
local API_COOLDOWN = 60

local function fetchServersToQueue()
    if tick() - lastAPICall < API_COOLDOWN then return end
    
    task.spawn(function()
        pcall(function()
            local url = "https://games.roblox.com/v1/games/" .. tostring(VPS_PLACE_ID) .. "/servers/Public?limit=100"
            lastAPICall = tick()
            
            local response = http_request({
                Url = url,
                Method = "GET",
                Headers = {
                    ["User-Agent"] = "Roblox/WinInet",
                    ["Accept"] = "application/json"
                }
            })
            
            if response and response.StatusCode == 200 then
                local data = HttpService:JSONDecode(response.Body)
                if data and data.data then
                    serverQueue = {}
                    for _, server in ipairs(data.data) do
                        if server.id and server.id ~= game.JobId then
                            table.insert(serverQueue, server.id)
                        end
                    end
                    for i = #serverQueue, 2, -1 do
                        local j = math.random(i)
                        serverQueue[i], serverQueue[j] = serverQueue[j], serverQueue[i]
                    end
                    print("‚úÖ Queued " .. #serverQueue .. " servers")
                end
            end
        end)
    end)
end

local function hopToNextServer()
    -- Versuch 1: Queued Server
    if #serverQueue > 0 then
        local serverId = table.remove(serverQueue, 1)
        local success = pcall(function()
            TeleportService:TeleportToPlaceInstance(VPS_PLACE_ID, serverId, Players.LocalPlayer)
        end)
        if success then return true end
    end
    
    -- Versuch 2: Random
    local success = pcall(function()
        TeleportService:Teleport(VPS_PLACE_ID, Players.LocalPlayer)
    end)
    return success
end

-- ===============================
-- MAIN LOOP
-- ===============================
local totalScanned = 0
local totalFound = 0
local scanInProgress = false

local function performFullScan()
    if scanInProgress then return end
    scanInProgress = true
    
    local serverId = game.JobId
    
    -- Phase 1: Warte auf Game Load
    updateStatus("Waiting for game load...")
    local loadStartTime = tick()
    
    repeat 
        task.wait(0.2)
        if tick() - loadStartTime > WAIT_FOR_LOAD then
            updateStatus("Load timeout, skipping...")
            scanInProgress = false
            return
        end
    until workspace:FindFirstChild("Plots") and #workspace:GetChildren() >= 5
    
    print("‚úÖ Game loaded! Starting scan...")
    
    -- Phase 2: Scan - USING FIXED SCANNER!
    updateStatus("Scanning brainrots & highlights...")
    task.wait(0.5)
    
    local brainrots = scanAllBrainrots()  -- ‚úÖ Using V5.0 method!
    local highlights = scanAllHighlights()
    totalScanned = totalScanned + 1
    
    if #brainrots > 0 or #highlights > 0 then
        totalFound = totalFound + #brainrots
        updateStatus(string.format("‚úÖ Found %d brainrots + %d highlights!", #brainrots, #highlights))
        
        -- Send to API
        sendToAPI(brainrots, highlights, serverId)
        
        -- Send special brainrots to Discord
        task.spawn(function()
            pcall(function()
                local specialBrainrots = {}
                for _, br in ipairs(brainrots) do
                    local genNum = br.genNum or (parseMoneyPerSec(br.generation) / 1e6)
                    local nameNorm = (br.name or ""):lower()
                    if SPECIAL_BRAINROTS[nameNorm] or genNum >= SPECIAL_MIN_GEN then
                        table.insert(specialBrainrots, br)
                    end
                end
                if #specialBrainrots > 0 then
                    sendToSpecialWebhook(specialBrainrots, serverId)
                end
            end)
        end)
        
        task.wait(1)
    else
        updateStatus(string.format("No brainrots (Servers scanned: %d)", totalScanned))
    end
    
    scanInProgress = false
end

-- ===============================
-- AUTO HOP LOOP
-- ===============================
print("‚úÖ Scanner V8.1 FIXED loaded!")
print("‚úÖ Using V5.0 scanning method!")
print("‚ö° Total cycle time: " .. HOP_DELAY .. " seconds")

-- Fetch server queue im Hintergrund
task.spawn(function()
    while true do
        fetchServersToQueue()
        task.wait(API_COOLDOWN)
    end
end)

-- Main loop
task.spawn(function()
    task.wait(1)
    
    while true do
        performFullScan()
        
        local remaining = HOP_DELAY - (WAIT_FOR_LOAD + SCAN_TIME)
        if remaining > 0 then
            for i = math.floor(remaining), 1, -1 do
                updateTimer(string.format("Next hop in %d seconds...", i))
                task.wait(1)
            end
        end
        
        updateStatus("Hopping to next server...")
        updateTimer("")
        
        if not hopToNextServer() then
            updateStatus("Hop failed, retrying...")
            task.wait(2)
        else
            task.wait(1)
        end
    end
end)

-- Teleport failure handler
TeleportService.TeleportInitFailed:Connect(function(player, result, errorMessage)
    print("‚ö†Ô∏è Teleport failed:", result, errorMessage)
    scanInProgress = false
    task.wait(1)
    hopToNextServer()
end)

print("üî• Scanner running!")
print("üìä Stats will update as servers are scanned...")
